#TODO
#Average function - averages out the distrobution evenly. if there's a super easy way to do this online, do it
#Automatic boarder algorithm - input resolution, it centers the boarder on the screen
#       bonus fun, change the wavy things on the sides to adhere to this change
#Antialiasing?? found some stuff online about that
#Changing colors based on mood maybe??
#render to mp4 for streaming??
#Add 3d functionality to this, just see how it looks. but this is a later thing.


#algorithm that evens out the whole thing
#like
#if 15 of these aren't greater than 500, re-randomize
#or just randomize the values that are already in it to +200 or -200 of each, without going out of their bounds
#sounds kind of complicated, but i'd just have to create a variable for each of the numbers.
#this could be helpful for later when making the boarder creator for making the side thingies adhere to that

import sys, getopt, pyglet, time, random, copy
from datetime import datetime
from pyglet.gl import *
from pyglet.window import key

win = pyglet.window.Window(1280, 720, resizable=True)
#win = pyglet.window.Window(1920, 1080)
t = 33
dt = 0
fps = 30        #frames per second
lol = []        #list of lists
nlol = []       #new list of lists
wlol = []       #working list of lists
lims = []       #list of limits for each side of end vectors
scnl = []       #screen list DEBUG??
count = 0       #current counter of frames
#uplims = 5*60       #upper limit in seconds
uplims = 10       #upper limit in seconds
uplimf = fps*uplims     #upper limit in frames
running = False     #to set wlol to lol for the first time
D = False           #3d toggle  -   add support later
ws = True          #16:9 false, 4:3 true
fccm = False        #facecam toggle
frame = 0



'''
pass 't' value to list, which is the amount of vector loctions for each side of the board
returns random list of lists of coords for each side, according to what had been set for
the list of edge bounds from getxy
'''
def getlist(time):
    lx = []         #please dear god tell me there's a different way of doing this
    ly = []         #left
    bx = []         #bottom
    by = []
    tx = []         #top
    ty = []
    rx = []         #right
    ry = []
    #if one of these has not t/2 amount of floats that are above maxspread/2 (evenly distributed)
    #recalculate the one that does't have this
    print('pre',len(lx),len(ly),len(bx),len(by),len(tx),len(ty),len(rx),len(ry))
    #gonna have to change this for 4:3, 16:9... whatever
    for x in range(0,time):         #setting up boarders
        random.seed(datetime.now())
        lx.append(random.uniform(-100,150))
        ly.append(random.uniform(-100,win.height+100))
        bx.append(random.uniform(-300,win.width+300))
        by.append(random.uniform(-100,150))
        tx.append(random.uniform(-300,win.width+300))
        ty.append(random.uniform(win.height-75,win.height+100))
        rx.append(random.uniform(win.width-150,win.width+100))
        ry.append(random.uniform(-100,win.height+100))
        print('midst', len(lx),len(ly),len(bx),len(by),len(tx),len(ty),len(rx),len(ry))
        #print(lx)
    #print(lx,ly,bx,by,tx,ty,rx,ry)
    butts = [lx,ly,bx,by,tx,ty,rx,ry]
    return butts

'''
randomizes list of lists that has already been randomized
should take a list of coords that was generated by getlist, and output some random numbers
that arent too far off from what was generated
but within the bounds of the xy for each side
returns the pesudo randomized list
'''

def randlist(tls):
    #adsf
    print('hello!!')


'''
pass x and y of screen resoultion in pixels
sets the coordinates of what the x and y should be, and sets the list of 
bounds that the edges should be
returns the x and y coords as a list

This must also shrink anything as big, or bigger

If the resolution can fit inside of the window, let it
otherwise, create some scaling function
'''
def getxy(x, y):
    if x > win.width or y > win.height:
        print('hello!')
    else:   
        x1 = (x/2)+win.width//2
        x2 = (win.width//2)-(x/2)
        y1 = (y/2)+win.height//2
        y2 = (win.height//2)-(y/2)
    return [x1, y1, x2, y2]

    # xw1=win.width*0.075
    # xw2=win.width*0.925
    # yw1=win.height*0.075
    # yw2=win.height*0.925
    # #one of them
    # if not ws:
    #     glVertex2f(xw1,yw1)       #bottom left
    #     glVertex2f(xw1,yw2)       #top left
    #     glVertex2f(xw2,yw1)      #bottom right
    #     glVertex2f(xw1,yw2)       #top left
    #     glVertex2f(xw2,yw1)      #bottom right
    #     glVertex2f(xw2,yw2)      #top right



#APPEARENTLY some FUCK that wrote python thought that it would be a good idea to make 
#the f****** EQUAL SIGN CREATE A POINTER BETWEEN LISTS
#WHAT THE F***

def inc():      #i hate that I don't pass anything to this, but im not rewriting it
    for i in range(0,len(wlol)):
        for j in range(0,t):
            if int(nlol[i][j]) > int(wlol[i][j]):
                ut = nlol[i][j]-lol[i][j]
                wlol[i][j]=wlol[i][j]+(ut/uplimf)
            elif int(nlol[i][j]) < int(wlol[i][j]):
                ut = lol[i][j]-nlol[i][j]
                wlol[i][j]=wlol[i][j]-(ut/uplimf)

def udate(x):
    global count
    global lol
    global nlol
    global wlol
    global running
    global frame
    global scnl
    print('I was ', running)
    if running == False:
        running = True
        wlol=copy.deepcopy(lol)     #who thought this was a good idea
        print(f'lol = {lol}\nwlol = {wlol}')
    #print(f'previous to increment\nlol = {lol[0][0]}\nwlol = {wlol[0][0]}\n\n{len(wlol)} {len(nlol)}')
    count+=1
    frame+=1
    if count == uplimf:
        lol = nlol
        nlol = getlist(t)
        wlol=copy.deepcopy(lol)     #monkeys with typewriters maybe
        #lol = getlist(t)
        count = 0
    inc()
    print(f'{x} seconds since last, {count/24} secs since switchup')#\ntwlol = {twlol}\ntnlol = {tnlol}')

@win.event
def on_draw():
    #clear buffers
    glClear(GL_COLOR_BUFFER_BIT)
    #glColor3f(0.241, 0.139, .61)
    #draw only the points
    #glBegin(GL_POINTS)
    #draw outlines only
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)

    glBegin(GL_TRIANGLES)
    #glBegin(GL_QUADS)
    #glBegin(GL_QUAD_STRIP)
    #glBegin(GL_TRIANGLE_STRIP)

    #print('lol = ', lol[0][0], '\nnlol = ', nlol[0][0], '\nwlol = ', wlol[0][0])
    for i in range(0,len(lol), 2):
        for j in range(0,t):
            #print('hello!')
            glVertex2f(wlol[i][j],wlol[i+1][j])
    
    #just setup bounds first?
    #use percentages????????
    #from 
    glColor3f(1,1,1)
    #screen box
    glVertex2f(scnl[0],scnl[1])       #bottom left
    glVertex2f(scnl[0],scnl[3])       #top left
    glVertex2f(scnl[2],scnl[1])      #bottom right
    glVertex2f(scnl[0],scnl[3])       #top left
    glVertex2f(scnl[2],scnl[1])      #bottom right
    glVertex2f(scnl[2],scnl[3])      #top right
    print(f'x1 = {scnl[0]},y1  = {scnl[1]},x2 = {scnl[2]},y2 = {scnl[3]}')

    #4:3 box???
    xs1=win.width*0.83
    xs2=win.width*0.18
    ys1=win.height*0.075
    ys2=win.height*0.925
    # glVertex2f(xs1,ys1)       #bottom left
    # glVertex2f(xs1,ys2)       #top left
    # glVertex2f(xs2,ys1)      #bottom right
    # glVertex2f(xs1,ys2)       #top left
    # glVertex2f(xs2,ys1)      #bottom right
    # glVertex2f(xs2,ys2)      #top right



    #somewhere around 244x200...
    xf = win.width*0.87
    yf = win.height*0.20
    #print(win.width, win.height)
    #facecam box!!!
    if fccm:
        glVertex2f(xf,0)       #bottom left
        glVertex2f(xf,yf)       #top left
        glVertex2f(win.width,0)         #bottom right
        glVertex2f(xf,yf)       #top left
        glVertex2f(win.width,0)         #bottom right
        glVertex2f(win.width,yf)      #top right
    
    glEnd()
    #pyglet.image.get_buffer_manager().get_color_buffer().save('./scrnsht/'+str(frame).rjust(4,'0')+'.png')

scnl = getxy(870, 412)

lol = getlist(t)
#nlol = randlist(lol)
nlol = getlist(t)
pyglet.clock.schedule_interval(udate, 1/fps)
pyglet.app.run()

#not sure what to do here... ill implement later, just get the whole boarder thing working for now

def main():
    global D
    global ws
    global fccm
    try:
        opts, args = getopt.getopt(sys.argv,"h:3d:43:169:fccm:")
    except getopt.GetoptError as err:
      print(str(err))
      print(f'\n-h shows this screen\n-3d enables 3d mode\n-43 enables the 4:3 aspect ratio\n-169 enables 16:9 ratio(default)\n-fccm enables facecam')
      sys.exit(2)
    for opt, arg in opts:
        if opt in "-3d": D = True
        elif opt in "-43": ws = True
        elif opt in "-169": ws = False
        elif opt in "fccm": fccm = True

    while True:
        dt = clock.tick()

if __name__ == "__main__":
    main()



